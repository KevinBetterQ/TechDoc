# 深入了解 Go 的类型系统

**作者：Ankur Anand**

**原文地址：https://blog.ankuranand.com/2018/11/29/a-closer-look-at-go-golang-type-system/**

本文是一篇译文，主要通过一些例子来详细了解下 Go 的类型系统。

## 正文

让我们从一些基本的问题开始。

### 为什么需要类型？

在回答这个问题之前，我们需要先看下我们一般并不会接触到的关于编程语言的一些最原始的抽象层。

我们能接触到的关于机器描述数据的最基本层面是关于二进制的 0 和 1。这些就是机器能够理解的内容。

但是这些 0 和 1 对我们有意义么？至少对我来说毫无意义，除非有一天或许我可以像某些厉害的角色一样，或者是在计算机科学方面“开了天眼”。

所以我们可以上一个台阶，对这些 0 和 1 做一层抽象。

可以考虑下汇编语言里面的寄存器。比如有三个寄存器 R1，R2，R3。你能知道这三个寄存器里面存储的是什么类型的数据么？

```
# 把 R2 和 R3 寄存器中的内容相加并把结果存储到 R1 寄存器中
add $r1, $r2, $r3
```

因为这在汇编语言层面是无法判断的，你或许会以为它们是整型。但是实际上寄存器R1，R2，R3里面可以存储任意类型的数据。毕竟它们只是一些里面存储 0 和 1 的寄存器。加法运算虽然并不理解寄存器里面存储的数据，但是一样可以把它们加起来然后生成一个新的值再存储起来。

**所以数据类型的概念起源于更高的抽象，诸如在高级编程语言 C，Go，Java，Python 和 Javascript 中。** 数据类型是编程语言自身的特性。有些编程语言在运行的时候做类型检查，有些则是在编译期间。

### 那么什么是类型？

对于不同的编程语言来讲，数据类型的概念也有所不同。可以通过几种不同的方式来阐述数据类型的定义，但是基本上核心都是一致的。

1. 数据类型代表一组值；
2. 同时代表一些可以在这些值上面进行的操作。例如对于整数类型，我们可以执行加法和减法；对于字符串类型，我们可以执行拼接，检查是否为空等等；
3. 对于变量的类型检查一般是放在编译期间或者运行时，通过这些检查来确保数据的完整性，以及确保对数据的理解符合开发者的预期。

**所以一门编程语言的类型系统指定了对特定类型的数据可以执行的合法操作。**

类型检查的目标是确保针对正确的数据类型执行了运算操作，同时也确保程序遵循了类型系统设定的规则。这些检查要么是在编译期间对代码做转换的时候或者是在运行时执行代码的时候。通过这些操作，类型检查确保了对数值的理解符合预期。当我们到达机器层面的代码时，就不需要再检查什么了，因为都是 0 和 1 而已。对于这些 0 和 1，我们让机器做什么机器就会做什么。

类型系统确保了对由 0 和 1 的比特位构成的数值的理解符合预期。例如它确保不会在由 0 和 1 的比特位构成的整型数值上面执行一些非整型运算操作。毕竟这些操作是毫无意义的。

一个类型系统包含如下几个部分：

1. 基础类型 - 这些类型是包含在编程语言中的并且可以在任何由该编程语言编写的程序中使用。Go 也有一些基础类型，例如 int8，uint8，int16，uint16，int32，uint32 等；
2. 类型定义方法 - 编程语言提供的一种构造新的数据类型的方法。例如指向 T 的指针，其中 T 是基础类型或者是一个结构体类型；
3. 类型推断 - 编译器可以在我们并不显式指定变量的类型的时候自动推断出它的类型。Go 拥有单向的类型推断功能；
4. 类型兼容 - 类型系统允许的赋值类型。例如 `a int; b int8; a=b;` 这样的操作是否允许；如何判断两个类型相等；

### Go 中的类型系统

Go 的类型系统中有一些最基本的规范，我们将审视一些重要的部分。

在把所有的概念铺开之前，我想通过一些不同的例子来讲解 Go 类型系统的一些基本概念。我会在带领你研究这些例子的同时给你讲解一些重要的概念。

现在来仔细看下这几个代码片段，研究下哪个片段可以成功编译，另外无论代码是否可以编译都解释下原因。

![snippet-figure1](closer-look-at-go-type-system/snippet-figure1.png)

![snippet-figure2](closer-look-at-go-type-system/snippet-figure2.png)

我希望你把你的答案和分析出的原因记下来，这样我们在最后可以一起讨论下。

#### 命名类型

预定义的类型如 int，int64，float32，string 和 bool 都称为命名类型。即所有的预定义的布尔型，数值类型和字符串类型都是命名类型。

另外，我们使用类型声明方式定义的类型也叫做命名类型。

```go
var i int      // 命名类型
var b bool     // 命名类型

type myInt int // 命名类型
```

**一个命名的，自定义类型总是和其他的类型不同。**

#### 未命名类型

组合类型 - 数组，结构体，指针，函数，接口，切片，字典和通道类型都是未命名类型。

```
[]string          // 未命名类型
map[string]string // 未命名类型
[10]int           // 未命名类型
```

**上面组合类型中的基础类型描述了组合类型的构成方式，但是没有对组合类型本身进行命名。**

#### 底层类型

每个类型 T 都有对应的底层类型。

如果类型 T 是一个预定义的布尔类型，数值类型或者是字符串类型，那么它的底层类型就是 T 本身。否则 T 的底层类型就是类型 T 定义中所引用的的各类型。

![snippet-figure3](closer-look-at-go-type-system/snippet-figure3.png)

按照每行来解释各个类型：

1. 第 3 行和第 8 行： 其中的 string 类型是预定义的类型，所以底层类型就是 T 自身，换句话说类型 S 和字符串类型是一样的；
2. 第 5 行和第 7 行： 这里的类型都是字面类型，所以底层类型就是 T 自身，即 map[string]int 和指针 *N ，这些类型也是未命名类型；
3. 第 4，6，10 行： T 的底层类型就是 T 的类型定义中所引用的类型。例如 B 指向 A，所以 B 的底层是一个字符串类型。

这里我们需要再重点看下第 9 行，即 `type T map[S]int`。

这里 S 的底层类型是字符串类型，即 string。那么类型 `type T map[S]int` 的类型难道不是 `map[string]int` 而是 `map[S]int` 么？这里我们讨论的是未命令类型 `map[S]int` 的底层类型，它的底层类型判断在遇到第一个未命名类型的时候截止（即如规范所说，”如果 T 是一个字面类型，那么 T 对应的底层类型就是 T 本身“）。因为 `map[S]int` 是一个未命名类型，所以 `T` 的底层类型就是 `map[S]int`。

你或许会好奇我为什么特别强调这些关于未命名类型，命名类型和底层类型的规范。因为这对于我们后面将要讨论的内容至关重要。这些规范会帮助我们理解为什么上面的例子中的代码片段虽然意图几乎是一样，但是有些可以编译成功，有些则不行。

#### 可赋值性

可赋值性的要求是在把一个变量 v 赋值给一个类型 T 的变量的时候必须遵循的规则。

值 x 可以赋给类型 T 的变量必须符合以下几个条件中的一个：

1. 值 x 的类型和 T 一致；
2. 值 x 的类型 v 和类型 T 的底层类型一致，并且 v 和 T 中至少有一个不是命名类型；
3. T 是一个接口类型，并且值 x 的类型实现了该接口类型 T；
4. 值 x 的类型是一个双向的通道类型，T 是一个通道类型，值 x 的类型 v 和 T 拥有相同的元素类型，并且 v 和 T 中至少有一个不是命名类型；
5. 值 x 是预定义的值 nil，并且 T 是一个指针，函数，切片，字典，通道或者是接口类型；
6. 值 x 是一个无类型的常量，并且该常量可以用类型 T 的值来表示。

上面就是 Go 中的变量可赋值性要求所必须遵循的规范。

上面要求的条件都很容易理解，我们来看下其中的一个规则。

**规则：** 当可赋值的时候，参与赋值的两个类型必须拥有相同的底层类型，并且至少其中的一个类型不是命名类型。

我们来重新看下上图 4 和 5 中的代码片段。

```go
package main

type aInt int

func main() {
	var i int = 10
	var ai aInt = 100
	i = ai
	printAiType(i)
}

func printAiType(ai aInt) {
	print(ai)
}
```

上面的代码无法编译，并且会给出如下的错误。

```
8:4: cannot use ai (type aInt) as type int in assignment
9:13: cannot use i (type int) as type aInt in argument to printAiType
```

**原因：** 代码中的 i 是一个命名类型 int，而 ai 则是另外一个命名类型 aInt，虽然它们的底层类型都是 int。

```go
package main

type MyMap map[int]int

func main() {
	m := make(map[int]int)
	var mMap MyMap
	mMap = m
	printMyMapType(mMap)
	print(m)
}

func printMyMapType(mMap MyMap) {
	print(mMap)
}
```

上面的代码可以编译，因为虽然 mMap 是命名类型，但是 m 是一个未命名的类型，同时 m 和 mMap 的底层类型是一致的。

#### 类型转换

当符合以下条件中的一个时，非常量的值 x 可以转换为类型 T 的值：

1. 值 x 可赋值给类型 T；
2. 忽略结构体的标签，值 x 的类型和 T 拥有相同的底层类型；
3. 忽略结构体的标签，值 x 的类型和 T 都是非命名类型的指针类型，并且它们的指针类型的基本类型拥有相同的底层类型；
4. 值 x 的类型和 T 都是整型或者浮点型；
5. 值 x 的类型和 T 都是复数类型；
6. 值 x 的类型是整型，字节切片或者字符切片，同时 T 是字符串类型；
7. 值 x 的类型是字符串，同时 T 是字节切片或者字符切片；

上面就是 Go 中的类型转换所必须遵循的规范。

我们来看看上图 3 中的代码。

```go
package main

type Meter int64

type Centimeter int32

func main() {
	var cm Centimeter = 1000
	var m Meter
	m = Meter(cm)
	print(m)
	cm = Centimeter(m)
	print(cm)
}
```

上面的代码可以编译，因为类型 Meter 和 Centimeter 都是整型并且它们底层的值可以相互转换。

#### 类型一致性

**两个类型要么一致要么不同。**

在一般的类型系统中，有两种标准的方法来判断两个类型是否相同。其中一个方法是名称一致性，另外一个是结构一致性。

名称一致性最直接，两个类型当且仅当在名称相同的时候是一致的。在 Go 里面一个自定义的命名类型总是和其他的类型不同就是基于这个原则。

结构一致性是指两个类型当且仅当它们的“结构”是相同的，才被认为是一致的。当然这里的“结构”有不同的解释方法。在 Go 里面，两个类型被认为是一致的的条件是它们底层的字面类型是结构一致的并且不是命名类型。

所以甚至是预定义的命名类型或者是自定义的命名类型，例如 int 和 int64 类型都是不一致的。另外，接口类型的可赋值性是由结构类型系统所决定的。Go 里面没有所谓的“鸭子类型”。

现在让我们来看看结构体类型的转换规则。

**规则：** 忽略结构体的标签，值 x 的类型和 T 拥有一致的底层类型。

```go
package main

type Meter struct {
	value int64
}

type Centimeter struct {
	value int32
}

func main() {
	cm := Centimeter{
		value: 1000,
	}

	var m Meter
	m = Meter(cm)
	print(m.value)
	cm = Centimeter(m)
	print(cm.value)
}
```

注意术语“一致的底层类型”。因为类型 Meter 的属性 value 的类型是 int64 而 Centimeter 的属性 value 的类型是 int32，这两个命名类型是不一致的。

所以上面所示的图 2 的代码编译会出错。

接下来看看图 1 所示的代码。

```go
package main

type Meter struct {
	value int64
}

type Centimeter struct {
	value int64
}

func main() {
	cm := Centimeter{
		value: 1000,
	}

	var m Meter
	m = Meter(cm)
	print(m.value)
	cm = Centimeter(m)
	print(cm.value)
}
```

在这段代码中 Meter 和 Centimeter 的属性 value 拥有一致的类型 int64，所以它们的类型是一致的。因为这段代码可以通过编译。


### 结尾

我在写这篇文章的时候对 Go 的类型系统有了一个深入的了解，我希望这篇文章也能够帮助到你。